log(0.001)*0.001
log(1)*1
log(0.0000001)*0.0000001
4(pi)
4*pi
-0.41 + 0.582 + -0.435 + -0.159
()-0.41 + 0.582 + -0.435 + -0.159)
(-0.41 + 0.582 + -0.435 + -0.159)
(-0.41 + 0.582 + -0.435 + -0.159)/4
(-0.41 + 0.582 + -0.829 + -0.307)/4
(-0.41 + 0.686 + -0.829 + -0.307)/4
(-0.02 + 0.686 + -0.829 + -0.307)/4
12990/62000
4664 + 0.22*(62000-40525)
(-0.41 + 0.686 + -0.829 + -0.307)/4
(-0.02 + 0.686 + -0.829 + -0.307)/4
(-0.41 + 0.582 + -0.829 + -0.307)/4
(-0.41 + 0.582 + -0.435 + -0.159)/4
(-0.02 + 0.686 + -0.829 + -0.307)/4
load("/Users/gregorybritten/Dropbox/Working/GRADIENTS/TZCF/data/OCNPRD_time.rdata")
ls()
ocnord_date
ocnprd_date
(1/3)*(1-2)^2
(1/3)*((1-2)^2)
(1/3)*3*((1-2)^2)
7/16
im <- as.cimg(function(x,y) sin(x/5)+cos(x/4)*sin(y/2),128,128)#
ff <- FFT(im)
vignette("gettingstarted",package="imager")
1E6/(60*60*24)
(60*60*24)
1E6/(60*60*24)
0.05*1E6/(60*60*24)
(1/3) - (1/5)
2/15
0.6*365
4030+1615+695+69
3,155.27'
3,155.27
3155.27
3155.27*(26)
9*4
27+16
27+12
27+10
46*12
49*(3/4)
185/9
205/13
225/20
100/20
4*6
7.5/1.25
60*40*52
61*50*52
61*2500
61*2500/(65000 + 61*2500)
log10(1.2)
log10(1.2) - log10(1)
10^(log10(1.2) - log10(1))
10^((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2))
)
10^((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2)))
1.2/1 + 1.3/1.2
(1.2/1 + 1.3/1.2)
(1.2/1 + 1.3/1.2)/2
((1.2/1) + (1.3/1.2))/2
(1.2 + 1.3)/(1 + 1.2)
10^((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2)))
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2))))
1.3/1.2
1.2/1.0
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.2) - log10(1))))
1.2/2
1.2/1
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2))))
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2)) + ))
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2)) + )
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2))
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2))))
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.3) - log10(1.2)))
10^(0.5*((log10(1.2) - log10(1)) + (log10(1.2) - log10(1))))
10^(0.5*((log10(1.2/1)) + (log10(1.2/1)))
10^(0.5*(log10(1.2/1) + log10(1.2/1)))
10^(0.5*(log10(1.2/1) + log10(1.3/1.2)))
8317.57 - 1500
x <- rnorm(100)
y <- rnorm(100)
plot(x,y)
plot(x,y/x)
plot(x,y/x,xlim=c(0,1))
abline(h=0)
x <- rnorm(100)
yy <- -x + rnorm(sd=0.1)
yy <- -x + rnorm(100,sd=0.1)
plot(x,yy)
x <- yy*x
x <- rnorm(100)
yy <- -x + rnorm(100,sd=0.1)
y <- yy*x
plot(x,y)
y <- rnorm(100)
plot(x,y)
plot(x,y/x)
plot(log10(x),log10(y/x))
plot(log(x),log(y/x))
plot(x,y)
x <- rnorm(100)
y <- rnorm(100)
plot(x,y)
plot(log(x),log(y/x))
y <- rnorm(100,mean=10)
x <- rnorm(100,mean=10)
plot(x,y)
plot(log(x),log(y/x))
plot(x,y/x)
plot(x,y)
x <- rnorm(100,mean=10)
y <- rnorm(100,mean=10)
plot(x,y/x)
x <- rnorm(100)
y <- rnorm(100)
plot(x,y)
R.Version()
300*e^(-0.1*1)
300*exp(-0.1*1)
300*exp(-0.1*60)
1/(44*365)
250*6
8*300
7*300
9000/70
118300/102000
34/4
1000*(1/(365*100))
1000*(1/(100))
library(lmodel2)
install.packages('lmodel2')
library(lmodel2)
?lm2
y <- rnorm(100)
x <- rnorm(100)
fit <- lmodel2(y ~ x)
predict(fit)
?lmodel2
plot(fit)
library(ggplot2)#
library(lmodel2)#
#
dat <- data.frame(a=log10(rnorm(50, 30, 10)), b=log10(rnorm(50, 20, 2)))#
mod <- lmodel2(a ~ b, data=dat,"interval", "interval", 99)#
#
reg <- mod$regression.results#
names(reg) <- c("method", "intercept", "slope", "angle", "p-value")#
#
ggplot(dat) + #
  geom_point(aes(b, a)) +#
  geom_abline(data = reg, aes(intercept = intercept, slope = slope, colour = method))
mod
Skip to content#
Search…#
All gists#
Back to GitHub#
@gregbritten #
@stla#
stla/deming_v00.R#
Created 6 years ago • Report abuse#
0#
1#
Code#
Revisions#
1#
Forks#
1#
<script src="https://gist.github.com/stla/5fcd959576413798d4cc09e7493e53e9.js"></script>#
Deming regression: confidence and prediction intervals#
deming_v00.R#
#
#######  Estimates and covariance matrix ##########
deming.estim <- function(x,y,lambda=1){  # lambda=sigmay²/sigmax²#
  n <- length(x)#
  my <- mean(y)#
  mx <- mean(x)#
  SSDy <- crossprod(y-my)[,]#
  SSDx <- crossprod(x-mx)[,]#
  SPDxy <- crossprod(x-mx,y-my)[,] #
  A <- sqrt((SSDy - lambda*SSDx)^2 + 4*lambda*SPDxy^2)#
  B <- SSDy - lambda*SSDx#
  beta <- (B + A) / (2*SPDxy)#
  alpha <- my - mx*beta#
  sigma.uu <- ( (SSDy + lambda*SSDx) - A ) /(2*lambda) / (n-1)#
  s.vv <- crossprod(y-my-beta*(x-mx))/(n-2) # = (lambda+beta^2)*sigma.uu * (n-1)/(n-2)#
  # formula Gilard & Iles #
  sbeta2.Fuller <- (SSDx*SSDy-SPDxy^2)/n/(SPDxy^2/beta^2)#
  sbeta.Fuller <- sqrt(sbeta2.Fuller)#
  # standard error alpha Fuller #
  salpha2.Fuller <- s.vv/n + mx^2*sbeta2.Fuller  #
  salpha.Fuller <- sqrt(salpha2.Fuller)#
  # #
  V <- rbind( c(salpha2.Fuller, -mx*sbeta2.Fuller), c(-mx*sbeta2.Fuller, sbeta2.Fuller) )	#
  return(list(alpha=alpha,beta=beta, salpha.Fuller=salpha.Fuller, sbeta.Fuller=sbeta.Fuller, #
              V=V, #
              sigma=sqrt(sigma.uu*(n-1)/(n-2)))#
  ) #
}#
######## Confidence intervals about slope and intercept ##########
deming.ci <- function(x, y, lambda=1, level=95/100){#
  n <- length(x)#
  fit <- deming.estim(x,y, lambda=lambda) #
  sigma <- fit$sigma#
  V <- fit$V#
  a <- fit$alpha#
  b <- fit$beta#
  t <- qt(level,df=n-2)#
  out <- rbind(#
    a=c(a, a + c(-1,1)*t*sqrt(V[1,1])),#
    b=c(b, b + c(-1,1)*t*sqrt(V[2,2]))#
  )#
  colnames(out) <- c("estimate", "lower", "upper")#
  names(dimnames(out)) <- c("parameter", "")#
  return(out)#
}#
######## Confidence interval about a+b*xnew  ############
deming.ci.xnew <- function(x, y, lambda=1, xnew, level=95/100){#
  n <- length(x)#
  fit <- deming.estim(x,y, lambda=lambda) #
  sigma <- fit$sigma*sqrt((n-2)/(n-1))#
  H <- fit$V#
  xx <- c(1,xnew)#
  V <- xx%*%H%*%xx#
  T <- fit$alpha+fit$beta*xnew#
  t <- qt(1-(1-level)/2, df=n-2)#
  bounds <- T + c(-1,1)*t*sqrt(V)#
  return(c(estimate=T, lwr=bounds[1], upr=bounds[2]))#
}#
#########  Prediction intervals ################
deming.predict <-  function(x, y, lambda=1, xnew,  level=95/100){#
  n <- length(x)#
  fit <- deming.estim(x,y,lambda=lambda) #
  sigma <- fit$sigma#
  sigma.uu <- sigma^2*(n-2)/(n-1)#
  V <- fit$V#
  a <- fit$alpha#
  b <- fit$beta#
  ynew <- a+b*xnew#
  Xnew <- as.matrix(c(1,xnew))#
  sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)#
  ##  predict observed ynew given theoretical xnew#
  sd.ynew.Fuller <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew )#
  Lynew.Fuller <- ynew - t*sd.ynew.Fuller #
  Uynew.Fuller <- ynew + t*sd.ynew.Fuller #
  # predict from an observed x_new#
  sd.ynew.Fuller2 <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew + (b^2+V[2,2])*sigma.uu)#
  Lynew.Fuller2 <- ynew - t*sd.ynew.Fuller2 #
  Uynew.Fuller2 <- ynew + t*sd.ynew.Fuller2 #
  ##
  # predict difference (y-x) given theoretical xnew#
  sd.ynew.Fuller.diff <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew + sigma.uu) #
  Lynew.Fuller.diff <- ynew - xnew - t*sd.ynew.Fuller.diff#
  Uynew.Fuller.diff <- ynew - xnew + t*sd.ynew.Fuller.diff#
  ##
  out <- rbind(#
    pred1=c(ynew, Lynew.Fuller, Uynew.Fuller),#
    pred2=c(ynew, Lynew.Fuller2, Uynew.Fuller2),#
    diff=c(ynew-xnew, Lynew.Fuller.diff, Uynew.Fuller.diff)#
  )#
  colnames(out) <- c("estimate", "lower", "upper")#
  out#
}#
#
@gregbritten#
Add heading textAdd bold text, <Cmd+b>Add italic text, <Cmd+i>#
Add a quote, <Cmd+Shift+.>Add code, <Cmd+e>Add a link, <Cmd+k>#
Add a bulleted list, <Cmd+Shift+8>Add a numbered list, <Cmd+Shift+7>Add a task list, <Cmd+Shift+l>#
Directly mention a user or team#
Reference an issue or pull request#
Leave a comment#
No file chosen#
Attach files by dragging & dropping, selecting or pasting them.#
Styling with Markdown is supported#
Footer#
© 2022 GitHub, Inc.#
Footer navigation#
Terms#
Privacy#
Security#
Status#
Docs#
Contact GitHub#
Pricing#
API#
Training#
Blog#
About#
Deming regression: confidence and prediction intervals
#######  Estimates and covariance matrix ##########
deming.estim <- function(x,y,lambda=1){  # lambda=sigmay²/sigmax²#
  n <- length(x)#
  my <- mean(y)#
  mx <- mean(x)#
  SSDy <- crossprod(y-my)[,]#
  SSDx <- crossprod(x-mx)[,]#
  SPDxy <- crossprod(x-mx,y-my)[,] #
  A <- sqrt((SSDy - lambda*SSDx)^2 + 4*lambda*SPDxy^2)#
  B <- SSDy - lambda*SSDx#
  beta <- (B + A) / (2*SPDxy)#
  alpha <- my - mx*beta#
  sigma.uu <- ( (SSDy + lambda*SSDx) - A ) /(2*lambda) / (n-1)#
  s.vv <- crossprod(y-my-beta*(x-mx))/(n-2) # = (lambda+beta^2)*sigma.uu * (n-1)/(n-2)#
  # formula Gilard & Iles #
  sbeta2.Fuller <- (SSDx*SSDy-SPDxy^2)/n/(SPDxy^2/beta^2)#
  sbeta.Fuller <- sqrt(sbeta2.Fuller)#
  # standard error alpha Fuller #
  salpha2.Fuller <- s.vv/n + mx^2*sbeta2.Fuller  #
  salpha.Fuller <- sqrt(salpha2.Fuller)#
  # #
  V <- rbind( c(salpha2.Fuller, -mx*sbeta2.Fuller), c(-mx*sbeta2.Fuller, sbeta2.Fuller) )	#
  return(list(alpha=alpha,beta=beta, salpha.Fuller=salpha.Fuller, sbeta.Fuller=sbeta.Fuller, #
              V=V, #
              sigma=sqrt(sigma.uu*(n-1)/(n-2)))#
  ) #
}#
######## Confidence intervals about slope and intercept ##########
deming.ci <- function(x, y, lambda=1, level=95/100){#
  n <- length(x)#
  fit <- deming.estim(x,y, lambda=lambda) #
  sigma <- fit$sigma#
  V <- fit$V#
  a <- fit$alpha#
  b <- fit$beta#
  t <- qt(level,df=n-2)#
  out <- rbind(#
    a=c(a, a + c(-1,1)*t*sqrt(V[1,1])),#
    b=c(b, b + c(-1,1)*t*sqrt(V[2,2]))#
  )#
  colnames(out) <- c("estimate", "lower", "upper")#
  names(dimnames(out)) <- c("parameter", "")#
  return(out)#
}#
######## Confidence interval about a+b*xnew  ############
deming.ci.xnew <- function(x, y, lambda=1, xnew, level=95/100){#
  n <- length(x)#
  fit <- deming.estim(x,y, lambda=lambda) #
  sigma <- fit$sigma*sqrt((n-2)/(n-1))#
  H <- fit$V#
  xx <- c(1,xnew)#
  V <- xx%*%H%*%xx#
  T <- fit$alpha+fit$beta*xnew#
  t <- qt(1-(1-level)/2, df=n-2)#
  bounds <- T + c(-1,1)*t*sqrt(V)#
  return(c(estimate=T, lwr=bounds[1], upr=bounds[2]))#
}#
#########  Prediction intervals ################
deming.predict <-  function(x, y, lambda=1, xnew,  level=95/100){#
  n <- length(x)#
  fit <- deming.estim(x,y,lambda=lambda) #
  sigma <- fit$sigma#
  sigma.uu <- sigma^2*(n-2)/(n-1)#
  V <- fit$V#
  a <- fit$alpha#
  b <- fit$beta#
  ynew <- a+b*xnew#
  Xnew <- as.matrix(c(1,xnew))#
  sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)#
  ##  predict observed ynew given theoretical xnew#
  sd.ynew.Fuller <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew )#
  Lynew.Fuller <- ynew - t*sd.ynew.Fuller #
  Uynew.Fuller <- ynew + t*sd.ynew.Fuller #
  # predict from an observed x_new#
  sd.ynew.Fuller2 <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew + (b^2+V[2,2])*sigma.uu)#
  Lynew.Fuller2 <- ynew - t*sd.ynew.Fuller2 #
  Uynew.Fuller2 <- ynew + t*sd.ynew.Fuller2 #
  ##
  # predict difference (y-x) given theoretical xnew#
  sd.ynew.Fuller.diff <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew + sigma.uu) #
  Lynew.Fuller.diff <- ynew - xnew - t*sd.ynew.Fuller.diff#
  Uynew.Fuller.diff <- ynew - xnew + t*sd.ynew.Fuller.diff#
  ##
  out <- rbind(#
    pred1=c(ynew, Lynew.Fuller, Uynew.Fuller),#
    pred2=c(ynew, Lynew.Fuller2, Uynew.Fuller2),#
    diff=c(ynew-xnew, Lynew.Fuller.diff, Uynew.Fuller.diff)#
  )#
  colnames(out) <- c("estimate", "lower", "upper")#
  out#
}
deming.predict(x=rnorm(100), y=rnorm(100))
x <- rnorm(100)
y <- rnorm(100)
deming.predict(x=x, y=y)
deming.predict(x=x, y=y, xnew=x)
x
lambda=1
n <- length(x)#
  fit <- deming.estim(x,y,lambda=lambda) #
  sigma <- fit$sigma#
  sigma.uu <- sigma^2*(n-2)/(n-1)#
  V <- fit$V#
  a <- fit$alpha#
  b <- fit$beta
ynew <- a+b*xnew#
  Xnew <- as.matrix(c(1,xnew))#
  sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)
xnew = x
ynew <- a+b*xnew#
  Xnew <- as.matrix(c(1,xnew))#
  sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)
level = 95/100
ynew <- a+b*xnew#
  Xnew <- as.matrix(c(1,xnew))#
  sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)
Xnew
V
ynew <- a+b*xnew#
  Xnew <- as.matrix(cbind(1,xnew))#
  sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)
Xnew
t(Xnew)%*%V%*%Xnew
dim(Xnew)
dim(V)
ynew <- a+b*xnew#
  Xnew <- as.matrix(rbind(1,xnew))#
  sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)
t(Xnew)%*%V%*%Xnew
sigma.ee <- lambda*sigma.uu #
  t <- qt(1-(1-level)/2, n-2)#
  ##  predict observed ynew given theoretical xnew#
  sd.ynew.Fuller <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew )#
  Lynew.Fuller <- ynew - t*sd.ynew.Fuller #
  Uynew.Fuller <- ynew + t*sd.ynew.Fuller #
  # predict from an observed x_new#
  sd.ynew.Fuller2 <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew + (b^2+V[2,2])*sigma.uu)#
  Lynew.Fuller2 <- ynew - t*sd.ynew.Fuller2 #
  Uynew.Fuller2 <- ynew + t*sd.ynew.Fuller2 #
  ##
  # predict difference (y-x) given theoretical xnew#
  sd.ynew.Fuller.diff <- sqrt( sigma.ee + t(Xnew)%*%V%*%Xnew + sigma.uu) #
  Lynew.Fuller.diff <- ynew - xnew - t*sd.ynew.Fuller.diff#
  Uynew.Fuller.diff <- ynew - xnew + t*sd.ynew.Fuller.diff
sigma.ee
t(Xnew)%*%V
t(Xnew)%*%V%*%Xnew
V
deming.predict(x=x, y=y, xnew=x)
deming.predict(x=x, y=y, xnew=x[1])
deming.ci.xnew(x=x, y=y, xnew=x[1])
deming.ci.xnew(x=x, y=y, xnew=x)
deming.ci.xnew(x=x, y=y, xnew=x[5])
deming.ci.xnew(x=x, y=y, xnew=x[5]fit <- deming(aes ~ aas, data=arsenate, xstd=se.aas, ystd=se.aes)#
print(fit))
fit <- deming(aes ~ aas, data=arsenate, xstd=se.aas, ystd=se.aes)#
print(fit)
install.packages('deming')
fit <- deming(aes ~ aas, data=arsenate, xstd=se.aas, ystd=se.aes)
library(deming)
fit <- deming(aes ~ aas, data=arsenate, xstd=se.aas, ystd=se.aes)
summary(fit)
print(fit)
deming
fit$sigma
fit
deming(aes ~ aas, data=arsenate, xstd=se.aas, ystd=se.aes)
lm(aes ~ aas, data=arsenate)
summary(lm(aes ~ aas, data=arsenate))
residuals(fit)
10^1.8
21000*4
163 - 21000*4
163163 - 21000*4
(163163 - 21000*4)/12
3^4
21000/(40)
21000/(40*4)
(21000/(40*4))*25
110000/52/2
110000/52
110000/52*2
1670*2
log(100/0.01)
log(100/1)
x <- rnorm(100)
y <- rnorm(100)
summary(lm(y ~ x))
cor(x,y)
cor(x,y)^2
Ecov_where <- c("recruit")#
Ecov_mean  <- 0#
Ecov_sig   <- c(0.1,0.5) #units?#
ar1_y      <- c(0,0.95)#
beta       <- c(0.3,1.0) #units?#
obs_sig    <- c(1e-5,0.25) #units?#
#
df.mods       <- expand.grid(Ecov_sig=Ecov_sig, #
                             Ecov_phi = ar1_y, #
                             Ecov_mean = Ecov_mean, #
                             beta = beta, #
                             Ecov_where = Ecov_where, #
                             obs_sig = obs_sig)
nrow(df.mods)
25*16
100*16
41/343
2^7
2^6
128*4
50/5
21000*5
41/343
R.home()
.libPaths()
install.packages("TMB",type='source')
2^5
750*3
750*3*3
4250/3
750*3
750*5
750*5 + 500
16*26
463+ 479 + 495
680*52
690*4
25*12
log(0/100)
library(wham)
source(file.path(here::here(), "Ecov_study", "recruitment_functions", "code", "sim_management.R"))#
## verify_version()#
## simi=5;omj=1; emk=1#
om_inputs <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "om_inputs.RDS"))#
em_inputs <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "em_inputs.RDS"))#
df.ems <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "df.ems.RDS"))#
df.oms <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "df.oms.RDS"))
setwd('~/dropbox/working/state_space_assessments/SSRTWG/')
source(file.path(here::here(), "Ecov_study", "recruitment_functions", "code", "sim_management.R"))#
## verify_version()#
## simi=5;omj=1; emk=1#
om_inputs <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "om_inputs.RDS"))#
em_inputs <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "em_inputs.RDS"))#
df.ems <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "df.ems.RDS"))#
df.oms <- readRDS(file.path(here::here(),"Ecov_study", "recruitment_functions", "inputs", "df.oms.RDS"))
library(here
)
